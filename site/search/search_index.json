{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Index","text":"<p>This site contains the project documentation for the <code>semantido</code> project.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<ol> <li>Why Semantido</li> <li>Reference</li> <li>Tutorials</li> </ol>"},{"location":"explanation/","title":"Why Semantido","text":"<p>This part of the project documentation focuses on an understanding-oriented approach. The background of the project, as well as reasoning about how it was implemented.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Give context and background on your library</li> <li>Explain why you created it</li> <li>Provide examples and approaches of how     to work with it</li> <li>Help the reader make connections</li> </ul>"},{"location":"reference/","title":"Code Reference","text":"<p>Technical implementation of the <code>semantido</code> project.</p>"},{"location":"reference/#decorators","title":"Decorators","text":""},{"location":"reference/#semantic_table","title":"@semantic_table","text":"<p>A class decorator to enrich SQLAlchemy models with semantic metadata.</p> <p>This metadata is used by the <code>SQLAlchemySemanticBridge</code> to build a semantic layer, helping tools and LLMs understand the purpose, context, and filtering requirements of the underlying database table.Decorator for adding semantic information to SQLAlchemy models</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>A human-readable explanation of what the table represents.</p> required <code>synonyms</code> <code>Optional[list[str]]</code> <p>Alternative names for the entity (e.g., [\"client\", \"customer\"]).</p> <code>None</code> <code>sql_filters</code> <code>Optional[list[str]]</code> <p>A list of SQL fragments used for default filtering or row-level security.</p> <code>None</code> <code>application_context</code> <code>Optional[str]</code> <p>The technical or functional scope within the app.</p> <code>None</code> <code>business_context</code> <code>Optional[str]</code> <p>The business domain or logic this table belongs to.</p> <code>None</code> <p>Examples:</p> <pre><code>@semantic_table(\n    description=\"User information and login profile\",\n    synonyms=[\"user profile\", \"client\"],\n    application_context=\"Registered users on the platform\"\n)\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True)\n</code></pre> Source code in <code>src/semantido/decorators/semantic_table.py</code> <pre><code>def semantic_table(\n    description: str,\n    synonyms: Optional[list[str]] = None,\n    sql_filters: Optional[list[str]] = None,\n    application_context: Optional[str] = None,\n    business_context: Optional[str] = None,\n):\n    \"\"\"A class decorator to enrich SQLAlchemy models with semantic metadata.\n\n    This metadata is used by the `SQLAlchemySemanticBridge` to build a semantic layer,\n    helping tools and LLMs understand the purpose, context, and filtering requirements\n    of the underlying database table.Decorator for adding semantic information to SQLAlchemy models\n\n    Args:\n        description: A human-readable explanation of what the table represents.\n        synonyms: Alternative names for the entity (e.g., [\"client\", \"customer\"]).\n        sql_filters: A list of SQL fragments used for default filtering or row-level security.\n        application_context: The technical or functional scope within the app.\n        business_context: The business domain or logic this table belongs to.\n\n    Examples:\n        ```python\n        @semantic_table(\n            description=\"User information and login profile\",\n            synonyms=[\"user profile\", \"client\"],\n            application_context=\"Registered users on the platform\"\n        )\n        class User(Base):\n            __tablename__ = \"users\"\n            id = Column(Integer, primary_key=True)\n        ```\n    \"\"\"\n\n    def decorator(cls):\n        cls.__semantic_description__ = description\n        cls.__semantic_synonyms__ = synonyms\n        cls.__semantic_sql_filters__ = sql_filters\n        cls.__semantic_application_context__ = application_context\n        cls.__semantic_business_context__ = business_context\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/#generators","title":"Generators","text":"<p>Extracts and synchronizes semantic metadata from SQLAlchemy models into a unified layer.</p> <p>Defines the data structures for the semantic representation of the database schema.</p>"},{"location":"reference/#semantido.generators.semantic_bridge.SQLAlchemySemanticBridge","title":"<code>SQLAlchemySemanticBridge</code>","text":"<p>Bridge between SQLAlchemy models and the semantic layer.</p> <p>This class serves as the extraction engine that inspects SQLAlchemy's internal registry to generate a structured <code>SemanticLayer</code>. It handles the conversion of SQL types to normalized types, builds join conditions for relationships, and retrieves semantic metadata attached via decorators.</p> Source code in <code>src/semantido/generators/semantic_bridge.py</code> <pre><code>class SQLAlchemySemanticBridge:\n    \"\"\"\n    Bridge between SQLAlchemy models and the semantic layer.\n\n    This class serves as the extraction engine that inspects SQLAlchemy's internal\n    registry to generate a structured `SemanticLayer`. It handles the conversion of\n    SQL types to normalized types, builds join conditions for relationships, and\n    retrieves semantic metadata attached via decorators.\n    \"\"\"\n\n    def __init__(self, base):\n        self.base = base\n        self.semantic_layer = SemanticLayer()\n        self._model_registry: dict[str, Type] = {}\n\n    def get_semantic_layer(self) -&gt; SemanticLayer:\n        \"\"\"\n        Retrieves the current semantic layer instance.\n\n        Returns:\n            SemanticLayer: The object containing extracted table and relationship metadata.\n        \"\"\"\n        return self.semantic_layer\n\n    def sync_from_models(self) -&gt; SemanticLayer:\n        \"\"\"\n        Extracts schema and semantic information from all mapped models.\n\n        This method clears any previously cached metadata and performs a full scan\n        of the SQLAlchemy registry to rebuild the semantic layer.\n\n        Returns:\n            SemanticLayer: The fully populated semantic layer.\n        \"\"\"\n        self.semantic_layer.tables.clear()\n        self.semantic_layer.relationships.clear()\n        self._model_registry.clear()\n\n        # Get all mapped classes\n        for mapper in self.base.registry.mappers:\n            clazz = mapper.class_\n            table_name = mapper.persist_selectable.name\n\n            # Add the current mapped table to the model registry\n            self._model_registry[table_name] = clazz\n\n            # Extract table information\n            table = self._extract_table(clazz, mapper)\n            self.semantic_layer.add_table(table)\n\n            # Extract table relationships\n            relationships = self._extract_relationships(clazz, mapper)\n            for relationship in relationships:\n                self.semantic_layer.add_relationship(relationship)\n\n        return self.semantic_layer\n\n    @staticmethod\n    def _extract_table(clazz: Type, mapper) -&gt; Table:\n        \"\"\"\n        Transforms a SQLAlchemy mapped class into a semantic Table definition.\n\n        Args:\n            clazz: The Python class representing the model.\n            mapper: The SQLAlchemy Mapper object containing low-level schema info.\n\n        Returns:\n            Table: A semantic representation of the table and its metadata.\n        \"\"\"\n\n        table_name = mapper.persist_selectable.name\n\n        description = getattr(clazz, \"__semantic_description__\", f\"Table: {table_name}\")\n        synonyms = getattr(clazz, \"__semantic_synonyms__\", [])\n        sql_filters = getattr(clazz, \"__semantic_sql_filters__\", [])\n        application_context = getattr(clazz, \"__semantic_application_context__\", None)\n        business_context = getattr(clazz, \"__semantic_business_context__\", None)\n\n        primary_keys = [key.name for key in mapper.primary_key]\n        primary_key = primary_keys[0] if primary_keys else None\n\n        columns = []\n\n        for name, prop in mapper.columns.items():\n            column = SQLAlchemySemanticBridge._extract_column(clazz, name, prop)\n            columns.append(column)\n\n        return Table(\n            name=table_name,\n            description=description,\n            columns=columns,\n            primary_key=primary_key,\n            synonyms=synonyms,\n            sql_filters=sql_filters,\n            application_context=application_context,\n            business_context=business_context,\n        )\n\n    @staticmethod\n    def _extract_column(clazz: Type, column_name: str, prop) -&gt; Column:\n        \"\"\"\n        Extracts semantic metadata and schema info for a specific column.\n\n        Args:\n            clazz: The model class where the column is defined.\n            column_name: The name of the column attribute.\n            prop: The SQLAlchemy column metadata or property.\n\n        Returns:\n            Column: The semantic Column object.\n        \"\"\"\n        sql_column_meta = prop\n\n        data_type = SQLAlchemySemanticBridge._map_sql_alchemy_type(sql_column_meta.type)\n        description = getattr(\n            clazz, f\"{column_name}_description\", f\"Column: {column_name}\"\n        )\n        privacy_level = getattr(\n            clazz, f\"{column_name}_privacy_level\", PrivacyLevel.PUBLIC\n        )\n        sample_values = getattr(clazz, f\"{column_name}_sample_values\", None)\n        synonyms = getattr(clazz, f\"{column_name}_synonyms\", [])\n        application_rules = getattr(clazz, f\"{column_name}_application_rules\", [])\n\n        # FK\n        foreign_keys = len(sql_column_meta.foreign_keys) &gt; 0\n        references = None\n        if foreign_keys:\n            fk = list(sql_column_meta.foreign_keys)[0]\n            references = f\"{fk.column.table.name}.{fk.column.name}\"\n\n        return Column(\n            name=column_name,\n            data_type=data_type,\n            description=description,\n            privacy_level=privacy_level,\n            sample_values=sample_values,\n            synonyms=synonyms,\n            is_foreign_key=foreign_keys,\n            references=references,\n            application_rules=application_rules,\n        )\n\n    @staticmethod\n    def _extract_relationships(clazz, mapper) -&gt; list[Relationship]:\n        \"\"\"Inspects a SQLAlchemy mapped class and its mapper to extract\n         semantic relationship metadata.\n\n        This method iterates through all relationships defined on the SQLAlchemy model,\n        identifying the target tables, determining the cardinality (One-to-Many vs Many-to-One),\n        builds the SQL join conditions, and retrieves any custom descriptions defined on the class.\n\n        Args:\n            clazz: The SQLAlchemy model class to inspect.\n            mapper: The SQLAlchemy Mapper object associated with the class.\n\n        Returns:\n            list: A list of Relationship objects representing the semantic links to other tables.\n        \"\"\"\n\n        relationships = []\n        for relationship_name, relationship_meta in mapper.relationships.items():\n            target = relationship_meta.mapper\n            target_table = target.persist_selectable.name\n            source_table = mapper.persist_selectable.name\n\n            if relationship_meta.uselist:\n                relationship_type = RelationshipType.ONE_TO_MANY\n            else:\n                relationship_type = RelationshipType.MANY_TO_ONE\n\n            join_condition = SQLAlchemySemanticBridge._build_join_condition(\n                relationship_meta\n            )\n\n            description = getattr(\n                clazz,\n                f\"{relationship_name}_relationship_description\",\n                f\"Relationship between {source_table} and {target_table}\",\n            )\n\n            relationships.append(\n                Relationship(\n                    from_table=source_table,\n                    to_table=target_table,\n                    join_condition=join_condition,\n                    relationship_type=relationship_type,\n                    description=description,\n                )\n            )\n\n        return relationships\n\n    @staticmethod\n    def _map_sql_alchemy_type(sql_type) -&gt; str:\n        \"\"\"\n        Maps SQLAlchemy types to Postgres types.\n\n        Args:\n            sql_type: The SQLAlchemy type instance\n\n        Returns:\n            str: A Postgres standardized type name (e.g., \"INTEGER\", \"VARCHAR\").\n        \"\"\"\n        type_mapping = {\n            String: \"VARCHAR\",\n            Text: \"TEXT\",\n            Integer: \"INTEGER\",\n            Float: \"FLOAT\",\n            Numeric: \"DECIMAL\",\n            Boolean: \"BOOLEAN\",\n            DateTime: \"TIMESTAMP\",\n            Date: \"DATE\",\n        }\n\n        for sqlalchemy_type, pg_type in type_mapping.items():\n            if isinstance(sql_type, sqlalchemy_type):\n                return pg_type\n\n        return str(sql_type)\n\n    @staticmethod\n    def _build_join_condition(relationship_meta) -&gt; str:\n        \"\"\"Builds the join condition string for a given relationship metadata.\n\n        Examples:\n            If you have a relationship between a users table and a posts table where\n            posts.user_id references users.id, the method returns:\n            \"users.id = posts.user_id\"\n\n            If the relationship involves multiple columns (a composite key), the method joins\n            them with AND. For example, if a sales table joins a products table on both\n            store_id and product_id the method returns:\n            \"products.store_id = sales.store_id AND products.product_id = sales.product_id\"\n\n        Args:\n            relationship_meta (RelationshipMeta):\n            The relationship metadata given by SQLAlchemy models.\n\n        Returns:\n            str: The join condition string for the given relationship metadata.\n\n        \"\"\"\n        local_cols = []\n        remote_cols = []\n\n        for local, remote in relationship_meta.local_remote_pairs:\n            local_cols.append(f\"{local.table.name}.{local.name}\")\n            remote_cols.append(f\"{remote.table.name}.{remote.name}\")\n\n        conditions = [\n            f\"{local} = {remote}\" for local, remote in zip(local_cols, remote_cols)\n        ]\n\n        return \" AND \".join(conditions)\n</code></pre>"},{"location":"reference/#semantido.generators.semantic_bridge.SQLAlchemySemanticBridge.get_semantic_layer","title":"<code>get_semantic_layer()</code>","text":"<p>Retrieves the current semantic layer instance.</p> <p>Returns:</p> Name Type Description <code>SemanticLayer</code> <code>SemanticLayer</code> <p>The object containing extracted table and relationship metadata.</p> Source code in <code>src/semantido/generators/semantic_bridge.py</code> <pre><code>def get_semantic_layer(self) -&gt; SemanticLayer:\n    \"\"\"\n    Retrieves the current semantic layer instance.\n\n    Returns:\n        SemanticLayer: The object containing extracted table and relationship metadata.\n    \"\"\"\n    return self.semantic_layer\n</code></pre>"},{"location":"reference/#semantido.generators.semantic_bridge.SQLAlchemySemanticBridge.sync_from_models","title":"<code>sync_from_models()</code>","text":"<p>Extracts schema and semantic information from all mapped models.</p> <p>This method clears any previously cached metadata and performs a full scan of the SQLAlchemy registry to rebuild the semantic layer.</p> <p>Returns:</p> Name Type Description <code>SemanticLayer</code> <code>SemanticLayer</code> <p>The fully populated semantic layer.</p> Source code in <code>src/semantido/generators/semantic_bridge.py</code> <pre><code>def sync_from_models(self) -&gt; SemanticLayer:\n    \"\"\"\n    Extracts schema and semantic information from all mapped models.\n\n    This method clears any previously cached metadata and performs a full scan\n    of the SQLAlchemy registry to rebuild the semantic layer.\n\n    Returns:\n        SemanticLayer: The fully populated semantic layer.\n    \"\"\"\n    self.semantic_layer.tables.clear()\n    self.semantic_layer.relationships.clear()\n    self._model_registry.clear()\n\n    # Get all mapped classes\n    for mapper in self.base.registry.mappers:\n        clazz = mapper.class_\n        table_name = mapper.persist_selectable.name\n\n        # Add the current mapped table to the model registry\n        self._model_registry[table_name] = clazz\n\n        # Extract table information\n        table = self._extract_table(clazz, mapper)\n        self.semantic_layer.add_table(table)\n\n        # Extract table relationships\n        relationships = self._extract_relationships(clazz, mapper)\n        for relationship in relationships:\n            self.semantic_layer.add_relationship(relationship)\n\n    return self.semantic_layer\n</code></pre>"},{"location":"reference/#semantido.generators.semantic_layer.Column","title":"<code>Column</code>  <code>dataclass</code>","text":"<p>Represents a database column with enriched semantic metadata.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The physical name of the column in the database.</p> <code>data_type</code> <code>str</code> <p>The normalized data type (e.g., VARCHAR, INTEGER).</p> <code>description</code> <code>str</code> <p>A human-readable explanation of the column's content.</p> <code>privacy_level</code> <code>PrivacyLevel</code> <p>The sensitivity classification of the data.</p> <code>sample_values</code> <code>Optional[list[str]]</code> <p>A list of example data points to help clarify the content.</p> <code>synonyms</code> <code>Optional[list[str]]</code> <p>Alternative terms for the column name.</p> <code>is_foreign_key</code> <code>bool</code> <p>Boolean flag indicating if this column links to another table.</p> <code>references</code> <code>Optional[str]</code> <p>The target table and column (format: 'table.column') if a foreign key.</p> <code>application_rules</code> <code>Optional[list[str]]</code> <p>Specific business logic or constraints applied to this column.</p> Source code in <code>src/semantido/generators/semantic_layer.py</code> <pre><code>@dataclass\nclass Column:\n    # pylint: disable=R0902\n    \"\"\"\n    Represents a database column with enriched semantic metadata.\n\n    Attributes:\n        name: The physical name of the column in the database.\n        data_type: The normalized data type (e.g., VARCHAR, INTEGER).\n        description: A human-readable explanation of the column's content.\n        privacy_level: The sensitivity classification of the data.\n        sample_values: A list of example data points to help clarify the content.\n        synonyms: Alternative terms for the column name.\n        is_foreign_key: Boolean flag indicating if this column links to another table.\n        references: The target table and column (format: 'table.column') if a foreign key.\n        application_rules: Specific business logic or constraints applied to this column.\n    \"\"\"\n\n    name: str\n    data_type: str\n    description: str\n    privacy_level: PrivacyLevel\n    sample_values: Optional[list[str]] = None\n    synonyms: Optional[list[str]] = None\n    is_foreign_key: bool = False\n    references: Optional[str] = None  # Format: table.column\n    application_rules: Optional[list[str]] = None\n</code></pre>"},{"location":"reference/#semantido.generators.semantic_layer.PrivacyLevel","title":"<code>PrivacyLevel</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Defines the data sensitivity levels for columns.</p> <p>Used to inform downstream consumers (like LLMs or BI tools) about the accessibility and security requirements of specific data points.</p> Source code in <code>src/semantido/generators/semantic_layer.py</code> <pre><code>class PrivacyLevel(Enum):\n    \"\"\"\n    Defines the data sensitivity levels for columns.\n\n    Used to inform downstream consumers (like LLMs or BI tools) about\n    the accessibility and security requirements of specific data points.\n    \"\"\"\n\n    PUBLIC = \"public\"\n    RESTRICTED = \"restricted\"\n    CONFIDENTIAL = \"confidential\"\n</code></pre>"},{"location":"reference/#semantido.generators.semantic_layer.Relationship","title":"<code>Relationship</code>  <code>dataclass</code>","text":"<p>Represents a semantic link between two database tables.</p> <p>Attributes:</p> Name Type Description <code>from_table</code> <code>str</code> <p>The name of the source table.</p> <code>to_table</code> <code>str</code> <p>The name of the target table.</p> <code>join_condition</code> <code>str</code> <p>The SQL fragment defining how the tables link.</p> <code>relationship_type</code> <code>RelationshipType</code> <p>The cardinality of the link.</p> <code>description</code> <code>str</code> <p>A plain-language explanation of the relationship logic.</p> Source code in <code>src/semantido/generators/semantic_layer.py</code> <pre><code>@dataclass\nclass Relationship:\n    \"\"\"\n    Represents a semantic link between two database tables.\n\n    Attributes:\n        from_table: The name of the source table.\n        to_table: The name of the target table.\n        join_condition: The SQL fragment defining how the tables link.\n        relationship_type: The cardinality of the link.\n        description: A plain-language explanation of the relationship logic.\n    \"\"\"\n\n    from_table: str\n    to_table: str\n    join_condition: str\n    relationship_type: (\n        RelationshipType  # Example: \"one-to-many\", \"many-to-one\", \"many-to-many\"\n    )\n    description: str\n</code></pre>"},{"location":"reference/#semantido.generators.semantic_layer.RelationshipType","title":"<code>RelationshipType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Specifies the cardinality of a database relationship.</p> <p>Helps in determining how to construct joins and aggregate data.</p> Source code in <code>src/semantido/generators/semantic_layer.py</code> <pre><code>class RelationshipType(Enum):\n    \"\"\"\n    Specifies the cardinality of a database relationship.\n\n    Helps in determining how to construct joins and aggregate data.\n    \"\"\"\n\n    ONE_TO_MANY = \"one-to-many\"\n    MANY_TO_ONE = \"many-to-one\"\n    MANY_TO_MANY = \"many-to-many\"\n</code></pre>"},{"location":"reference/#semantido.generators.semantic_layer.SemanticLayer","title":"<code>SemanticLayer</code>  <code>dataclass</code>","text":"<p>The central repository for all semantic metadata extracted from the database.</p> <p>This class serves as the final output of the synchronization process, containing structured information about tables, their relationships, and a global application glossary. It provides methods for serializing this metadata to JSON for use by external tools or LLMs.</p> Source code in <code>src/semantido/generators/semantic_layer.py</code> <pre><code>@dataclass\nclass SemanticLayer:\n    \"\"\"\n    The central repository for all semantic metadata extracted from the database.\n\n    This class serves as the final output of the synchronization process,\n    containing structured information about tables, their relationships,\n    and a global application glossary. It provides methods for serializing\n    this metadata to JSON for use by external tools or LLMs.\n    \"\"\"\n\n    tables: dict[str, Table] = field(default_factory=dict)\n    relationships: list[Relationship] = field(default_factory=list)\n    application_glossary: dict[str, str] = field(default_factory=dict)\n\n    def add_table(self, table: Table):\n        \"\"\"\n        Registers a new table definition in the semantic layer.\n\n        Args:\n            table: The Table object containing columns and semantic metadata.\n        \"\"\"\n        self.tables[table.name] = table\n\n    def add_relationship(self, relationship: Relationship):\n        \"\"\"\n        Registers a relationship between two tables in the semantic layer.\n\n        Args:\n            relationship: The Relationship object defining the join logic and cardinality.\n        \"\"\"\n        self.relationships.append(relationship)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Converts the entire semantic layer into a nested dictionary structure.\n\n        Returns:\n            dict: A dictionary representation suitable for JSON serialization.\n        \"\"\"\n        return {\n            \"tables\": {\n                name: {\n                    \"name\": table.name,\n                    \"description\": table.description,\n                    \"primary_key\": table.primary_key,\n                    \"synonyms\": table.synonyms,\n                    \"sql_filters\": table.sql_filters,\n                    \"application_context\": table.application_context,\n                    \"business_context\": table.business_context,\n                    \"columns\": [\n                        {\n                            \"name\": column.name,\n                            \"data_type\": column.data_type,\n                            \"description\": column.description,\n                            \"privacy_level\": (\n                                column.privacy_level.value\n                                if isinstance(column.privacy_level, Enum)\n                                else column.privacy_level\n                            ),\n                            \"sample_values\": column.sample_values,\n                            \"synonyms\": column.synonyms,\n                            \"is_foreign_key\": column.is_foreign_key,\n                            \"references\": column.references,\n                            \"application_rules\": column.application_rules,\n                        }\n                        for column in table.columns\n                    ],\n                }\n                for name, table in self.tables.items()\n            },\n            \"relationships\": [\n                {\n                    \"from_table\": relationship.from_table,\n                    \"to_table\": relationship.to_table,\n                    \"join_condition\": relationship.join_condition,\n                    \"relationship_type\": (\n                        relationship.relationship_type.value\n                        if isinstance(relationship.relationship_type, Enum)\n                        else relationship.relationship_type\n                    ),\n                    \"description\": relationship.description,\n                }\n                for relationship in self.relationships\n            ],\n        }\n\n    def to_json(self) -&gt; str:\n        \"\"\"\n        Exports the entire semantic layer as a formatted JSON string.\n\n        Returns:\n            str: Indented JSON string representing the semantic layer.\n        \"\"\"\n        return json.dumps(self.to_dict(), indent=4)\n\n    def save_to_file(self, file_path: str):\n        \"\"\"\n        Serializes and saves the semantic layer to a JSON file.\n\n        Args:\n            file_path: The filesystem path where the JSON file will be created.\n        \"\"\"\n        with open(file_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(self.to_dict(), f, indent=4)\n</code></pre>"},{"location":"reference/#semantido.generators.semantic_layer.SemanticLayer.add_relationship","title":"<code>add_relationship(relationship)</code>","text":"<p>Registers a relationship between two tables in the semantic layer.</p> <p>Parameters:</p> Name Type Description Default <code>relationship</code> <code>Relationship</code> <p>The Relationship object defining the join logic and cardinality.</p> required Source code in <code>src/semantido/generators/semantic_layer.py</code> <pre><code>def add_relationship(self, relationship: Relationship):\n    \"\"\"\n    Registers a relationship between two tables in the semantic layer.\n\n    Args:\n        relationship: The Relationship object defining the join logic and cardinality.\n    \"\"\"\n    self.relationships.append(relationship)\n</code></pre>"},{"location":"reference/#semantido.generators.semantic_layer.SemanticLayer.add_table","title":"<code>add_table(table)</code>","text":"<p>Registers a new table definition in the semantic layer.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>Table</code> <p>The Table object containing columns and semantic metadata.</p> required Source code in <code>src/semantido/generators/semantic_layer.py</code> <pre><code>def add_table(self, table: Table):\n    \"\"\"\n    Registers a new table definition in the semantic layer.\n\n    Args:\n        table: The Table object containing columns and semantic metadata.\n    \"\"\"\n    self.tables[table.name] = table\n</code></pre>"},{"location":"reference/#semantido.generators.semantic_layer.SemanticLayer.save_to_file","title":"<code>save_to_file(file_path)</code>","text":"<p>Serializes and saves the semantic layer to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The filesystem path where the JSON file will be created.</p> required Source code in <code>src/semantido/generators/semantic_layer.py</code> <pre><code>def save_to_file(self, file_path: str):\n    \"\"\"\n    Serializes and saves the semantic layer to a JSON file.\n\n    Args:\n        file_path: The filesystem path where the JSON file will be created.\n    \"\"\"\n    with open(file_path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(self.to_dict(), f, indent=4)\n</code></pre>"},{"location":"reference/#semantido.generators.semantic_layer.SemanticLayer.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the entire semantic layer into a nested dictionary structure.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary representation suitable for JSON serialization.</p> Source code in <code>src/semantido/generators/semantic_layer.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the entire semantic layer into a nested dictionary structure.\n\n    Returns:\n        dict: A dictionary representation suitable for JSON serialization.\n    \"\"\"\n    return {\n        \"tables\": {\n            name: {\n                \"name\": table.name,\n                \"description\": table.description,\n                \"primary_key\": table.primary_key,\n                \"synonyms\": table.synonyms,\n                \"sql_filters\": table.sql_filters,\n                \"application_context\": table.application_context,\n                \"business_context\": table.business_context,\n                \"columns\": [\n                    {\n                        \"name\": column.name,\n                        \"data_type\": column.data_type,\n                        \"description\": column.description,\n                        \"privacy_level\": (\n                            column.privacy_level.value\n                            if isinstance(column.privacy_level, Enum)\n                            else column.privacy_level\n                        ),\n                        \"sample_values\": column.sample_values,\n                        \"synonyms\": column.synonyms,\n                        \"is_foreign_key\": column.is_foreign_key,\n                        \"references\": column.references,\n                        \"application_rules\": column.application_rules,\n                    }\n                    for column in table.columns\n                ],\n            }\n            for name, table in self.tables.items()\n        },\n        \"relationships\": [\n            {\n                \"from_table\": relationship.from_table,\n                \"to_table\": relationship.to_table,\n                \"join_condition\": relationship.join_condition,\n                \"relationship_type\": (\n                    relationship.relationship_type.value\n                    if isinstance(relationship.relationship_type, Enum)\n                    else relationship.relationship_type\n                ),\n                \"description\": relationship.description,\n            }\n            for relationship in self.relationships\n        ],\n    }\n</code></pre>"},{"location":"reference/#semantido.generators.semantic_layer.SemanticLayer.to_json","title":"<code>to_json()</code>","text":"<p>Exports the entire semantic layer as a formatted JSON string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Indented JSON string representing the semantic layer.</p> Source code in <code>src/semantido/generators/semantic_layer.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"\n    Exports the entire semantic layer as a formatted JSON string.\n\n    Returns:\n        str: Indented JSON string representing the semantic layer.\n    \"\"\"\n    return json.dumps(self.to_dict(), indent=4)\n</code></pre>"},{"location":"reference/#semantido.generators.semantic_layer.Table","title":"<code>Table</code>  <code>dataclass</code>","text":"<p>Represents a database table enriched with semantic and contextual information.</p> <p>By capturing application and business contexts, this class helps disambiguate entities that might have generic names but specific roles in different domains.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The physical name of the table in the database.</p> <code>description</code> <code>str</code> <p>A human-readable explanation of the table's purpose.</p> <code>columns</code> <code>list[Column]</code> <p>A list of Column objects belonging to this table.</p> <code>primary_key</code> <code>str</code> <p>The name of the primary key column.</p> <code>synonyms</code> <code>Optional[list[str]]</code> <p>Alternative names for the entity represented by the table.</p> <code>sql_filters</code> <code>Optional[list[str]]</code> <p>Default SQL fragments for filtering or security.</p> <code>application_context</code> <code>Optional[str]</code> <p>The functional area of the application using this table.</p> <code>business_context</code> <code>Optional[str]</code> <p>The business domain or logic this table serves.</p> Source code in <code>src/semantido/generators/semantic_layer.py</code> <pre><code>@dataclass\nclass Table:\n    # pylint: disable=R0902\n    \"\"\"\n    Represents a database table enriched with semantic and contextual information.\n\n    By capturing application and business contexts, this class helps disambiguate\n    entities that might have generic names but specific roles in different domains.\n\n    Attributes:\n        name: The physical name of the table in the database.\n        description: A human-readable explanation of the table's purpose.\n        columns: A list of Column objects belonging to this table.\n        primary_key: The name of the primary key column.\n        synonyms: Alternative names for the entity represented by the table.\n        sql_filters: Default SQL fragments for filtering or security.\n        application_context: The functional area of the application using this table.\n        business_context: The business domain or logic this table serves.\n    \"\"\"\n\n    name: str\n    description: str\n    columns: list[Column]\n    primary_key: str\n    synonyms: Optional[list[str]] = None\n    sql_filters: Optional[list[str]] = None\n    application_context: Optional[str] = None\n    business_context: Optional[str] = None\n</code></pre>"},{"location":"reference/#models","title":"Models","text":"<p>Defines the standard and semantic-enabled SQLAlchemy declarative base classes.</p>"},{"location":"reference/#semantido.models.declarative_base.Base","title":"<code>Base</code>","text":"<p>               Bases: <code>DeclarativeBase</code></p> <p>Default SQLAlchemy base class for declarative models.</p> Source code in <code>src/semantido/models/declarative_base.py</code> <pre><code>class Base(DeclarativeBase):\n    # pylint: disable=R0903\n    \"\"\"Default SQLAlchemy base class for declarative models.\"\"\"\n</code></pre>"},{"location":"reference/#semantido.models.declarative_base.SemanticDeclarativeBase","title":"<code>SemanticDeclarativeBase</code>","text":"<p>               Bases: <code>SemanticBase</code>, <code>DeclarativeBase</code></p> <p>Mixin for declarative models with semantic data support.</p> Source code in <code>src/semantido/models/declarative_base.py</code> <pre><code>class SemanticDeclarativeBase(SemanticBase, DeclarativeBase):\n    \"\"\"Mixin for declarative models with semantic data support.\"\"\"\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This part of the project documentation focuses on a learning-oriented approach. You'll learn how to get started with the code in this project.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Help newcomers with getting started</li> <li>Teach readers about your library by making them     write code</li> <li>Inspire confidence through examples that work for     everyone, repeatably</li> <li>Show concrete examples, no abstractions</li> <li>Provide the minimum necessary explanation</li> <li>Avoid any distractions</li> </ul>"}]}